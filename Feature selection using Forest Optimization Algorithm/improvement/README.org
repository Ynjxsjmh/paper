* 想法一
原来的算法树与树之间没有任何联系，这里将初始树全部作为祖先，每个祖先代表不同的族群。

原来的算法都是随机的更改属性。现在不同的树会形成族群，每个族群留给后代的性状评价不同，我们统计每个族群的这些信息。

每颗树有择优的本能，会保留自身中较优的性状，这些信息都是从祖先中得到的。

如何评价性状更好：族群中所有树的 accuracy 以及 dimension reduction 之和除以对应性状出现的次数对每个性状进行评分。

#+BEGIN_EXAMPLE
1 0 1 8
0 1 1 10
1 0 1 11

pre(1) = (8+11)/2 = 9.5
pre(2) = (10)/1 = 10
pre(3) = (8+10+11)/3 = 9.7
#+END_EXAMPLE

这里每次更换时留下族群中性状前 K 好的

评分高即为性状好

自开始迭代起，每次迭代多保留一个性状。

* 想法二
原来满足条件的树都同等的产生 LSC 颗后代

不同的树的繁衍能力不同，表现优秀的树应该能得到更多的资源，即繁衍出更多的后代。

如何评判一个树是否优秀：当前 best tree 的 85%

较优性状体现在使 accuracy 更高

* 想法三
真实的森林的演化有生老病死，也有优胜劣汰。

原来的算法树只有淘汰，并没有真正的删除。

新增一个控制森林总数的参数，年龄大的树以及效果不好的树不再参与任何过程，但是为样本作出贡献。

评价效果不好：和 best tree 的 accuracy 相比

效果不好不一定代表年龄大，淘汰前给其繁衍的机会。（体现在 global seeding 阶段）。选中后给其繁衍 X 颗后代的机会，然后淘汰。（给不好的树一个机会，因为这不代表其产生的后代不好，当然此时不能利用其祖先信息，防止被带跑了）

* 如何避免局部最优
每隔一段时间，对这些族群进行人工干预，对发展好的族群进行抑制，给发展不好的族群更多的机会。

时间体现在运行时间或迭代次数

同时被抑制的族群在抑制前给一个机会，在上段时间是否产生一个更优解。否则该族群只留下前 K 个最优树，并且这些树失去繁殖能力。

又考虑到该族群新生树的性状可能和祖先有较大区别，也保留新生树

* 人工选择1
记录每次的 best tree，对这些 best tree 的性状进行评估。方法同上

先前考虑的是同一种族的优良性状，这里考虑了所有种族的优良性状。

评估完后选择前 K 个性状评估，与 best tree 进行比较。

K 的选取标准在 best tree 的降维率附近

* 人工选择2
经过 N 次迭代之后，已有的数据评估样本也足够大了。

这里对所有产生的树的性状进行评估，方法同上

人工选择 1 和 自然选择是选取优良性状。这里考虑的是所有性状。

评估完后选择前 K 个性状评估，与 best tree 进行比较。

K 的选取标准在 best tree 的降维率附近
